use std::collections::HashMap;
use std::path::PathBuf;
use std::sync::Arc;

use actix_web::{App, HttpServer};
use async_trait::async_trait;
use pact_verifier::callback_executors::{NullRequestFilterExecutor, ProviderStateExecutor};
use pact_verifier::{FilterInfo, ProviderInfo, ProviderTransport, VerificationOptions, PactSource, PublishOptions};
use pact_models::http_utils::HttpAuth;
use portpicker::pick_unused_port;

use shipping::shipping_service::{get_quote, ship_order};
use serde_json::Value;
use pact_models::prelude::ProviderState;

#[tokio::test(flavor = "multi_thread", worker_threads = 2)]
async fn verify_shipping_pact() {
    // Pick ports for provider and quote stub
    let port = pick_unused_port().expect("No free port for provider");
    let quote_port = pick_unused_port().expect("No free port for quote service");
    
    // Start the shipping service HTTP server in the background.
    // Start stub quote service that returns fixed float value
    let quote_server = HttpServer::new(|| App::new().default_service(actix_web::web::to(|| async { "5.99" })))
        .bind(("127.0.0.1", quote_port)).expect("bind quote").run();
    let _quote_handle = tokio::spawn(quote_server);

    // point provider to stub quote service
    std::env::set_var("QUOTE_ADDR", format!("http://127.0.0.1:{}", quote_port));

    let server = HttpServer::new(|| {
        App::new()
            .service(get_quote)
            .service(ship_order)
    })
    .bind(("127.0.0.1", port)).expect("failed to bind port")
    .run();

    let srv_handle = tokio::spawn(server);

    // drop _quote_handle when test ends
    let _ = _quote_handle;

    // Build ProviderInfo for pact verifier.
    let provider_info = ProviderInfo {
        name: "ShippingService".to_string(),
        host: "127.0.0.1".to_string(),
        transports: vec![ProviderTransport {
            transport: "http".to_string(),
            port: Some(port),
            path: None,
            scheme: Some("http".to_string()),
        }],
        ..Default::default()
    };

    // Determine the source of the pact(s):
    // 1. If broker environment variables are present, pull pacts from the broker.
    // 2. Otherwise, fall back to a local pact file generated by the consumer tests.
    let pact_source = if let Ok(broker_url) = std::env::var("PACT_BROKER_URL") {
        let auth = match (
            std::env::var("PACT_BROKER_USERNAME").ok(),
            std::env::var("PACT_BROKER_PASSWORD").ok(),
        ) {
            (Some(user), Some(pass)) => Some(HttpAuth::User(user, Some(pass))),
            (Some(user), None) => Some(HttpAuth::User(user, None)),
            _ => None,
        };
        PactSource::BrokerUrl(provider_info.name.clone(), broker_url, auth, vec![])
    } else {
        let pact_path: PathBuf = PathBuf::from(env!("CARGO_MANIFEST_DIR"))
            .join("../frontend/pacts/Frontend-ShippingService.json");
        PactSource::File(pact_path.to_string_lossy().to_string())
    };

    // Prepare options â€“ we don't need any special filters or headers.
    let verification_options = VerificationOptions::<NullRequestFilterExecutor> {
        request_filter: None,
        disable_ssl_verification: false,
        request_timeout: 5000,
        custom_headers: Default::default(),
        coloured_output: false,
        no_pacts_is_error: true,
        exit_on_first_failure: false,
        run_last_failed_only: false,
    };

    // -----------------------------------------------------------------
    // Provider State Executor
    // -----------------------------------------------------------------
    // Pacts can include one or more `providerStates` that describe the data
    // or system pre-conditions the provider must satisfy before an
    // interaction is verified (for example: "order ABC exists").
    //
    // During verification the Pact framework calls `ProviderStateExecutor::call`
    // with the state name and a `setup` flag (`true` before the interaction,
    // `false` after) giving us a chance to create records, seed databases, or
    // stub external services. After all interactions the verifier may invoke
    // `teardown()` allowing cleanup.
    //
    // For now our consumer pact does **not** define any provider states, so a
    // *no-op* implementation is sufficient.  If you later add
    // `providerStates` to the consumer tests **replace this executor** with
    // logic that prepares (and optionally cleans up) the required state.
    #[derive(Debug, Clone)]
    struct NoOpProviderState;

    #[async_trait]
    impl ProviderStateExecutor for NoOpProviderState {
        async fn call(
            self: Arc<Self>,
            _interaction_id: Option<String>,
            _provider_state: &ProviderState,
            _setup: bool,
            _client: Option<&reqwest::Client>,
        ) -> anyhow::Result<HashMap<String, Value>> {
            Ok(HashMap::new())
        }

        fn teardown(self: &Self) -> bool {
            true
        }
    }

    let provider_state_executor = Arc::new(NoOpProviderState);

    // -----------------------------------------------------------------
    // Publishing verification results back to the Pact Broker
    // -----------------------------------------------------------------
    // CI pipelines set `GIT_COMMIT` and `GIT_BRANCH` so we can associate the
    // verification results with a concrete provider version/branch in the
    // Pact Broker. Supplying these via `PublishOptions` enables the Broker's
    // "can-i-deploy?" gate and visual history.
    //
    // Local runs usually *lack* these env vars, so we treat that case as
    // "do not publish" to avoid errors and unnecessary Broker noise.
    //
    // If you want to publish results from another environment, ensure the
    // equivalent metadata is exported or adjust this block to obtain the
    // commit/branch info by another means (e.g. using the `git2` crate).
    let publish_options = if let (Ok(commit), Ok(branch)) = (std::env::var("GIT_COMMIT"), std::env::var("GIT_BRANCH")) {
        Some(PublishOptions {
            provider_version: Some(commit),
            build_url: None,
            provider_tags: vec![],
            provider_branch: Some(branch),
        })
    } else {
        None
    };

    // Run the verifier against the pact file.
    let result = pact_verifier::verify_provider_async(
        provider_info,
        vec![pact_source],
        FilterInfo::None,
        vec![],
        &verification_options,
        publish_options.as_ref(),
        &provider_state_executor,
        None,
    )
    .await
    .expect("Pact verification process errored");

    // Assert all interactions passed.
    assert!(result.result, "Pact verification failed, see output for details");

    // Shut down the server task.
    srv_handle.abort();
}
